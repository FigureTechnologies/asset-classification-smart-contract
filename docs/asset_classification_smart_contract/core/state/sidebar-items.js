initSidebarItems({"fn":[["asset_definitions","The main entrypoint access for AssetDefinition state.  Establishes an index map for all definitions, allowing the standard save(), load() and iterator functionality. Private access to ensure only helper functions below are used"],["config_read_v2",""],["config_v2",""],["insert_asset_definition","Inserts a new asset definition into storage. If a value already exists, an error will be returned. Note: Asset definitions must contain a unique asset_type value, as well as a unique scope_spec_address.  Either unique constraint being violated will return an error."],["load_asset_definition_by_scope_spec","Finds an existing asset definition by scope spec address, or returns an error if no definition is found."],["load_asset_definition_by_type","Finds an existing asset definition by asset type, or returns an error if no definition is found."],["may_load_asset_definition_by_scope_spec","Finds an existing asset definition in state by checking against the provided scope spec address, returning an Option that reflects whether or not the definition exists."],["may_load_asset_definition_by_type","Finds an existing asset definition in state by checking against the provided asset type, returning an Option that reflects whether or not the definition exists"],["replace_asset_definition","Replaces an existing asset definition in state with the provided value. If no value exists for the given definition, an error will be returned. Note: IndexedMap (the type asset_definitions() function returns) provides a really nice update() function that allows two branches (one for success and one for failure to find) that seems ideal for this functionality, but it requires a non-reference version of the data to be used. This requires that the provided definition must be cloned, which makes it vastly inefficient compared to this implementation."]],"static":[["ASSET_META_KEY",""],["STATE_V2_KEY",""]],"struct":[["AssetDefinitionIndexes","Boilerplate implementation of indexes for an IndexMap around state. This establishes a unique index on the scope spec address to ensure that saves cannot include duplicate scope specs. If it becomes a requirement in the future that we have duplicate scope specs, we will need to swap to a MultiIndex, and a lot of the lookups in the contract will fall apart"],["StateV2",""]]});