use crate::core::error::ContractError;
use crate::core::state::{config_read, AssetScopeAttribute};
use crate::util::functions::generate_asset_attribute_name;
use cosmwasm_std::{to_binary, Addr, Binary, Deps};
use provwasm_std::{ProvenanceQuerier, ProvenanceQuery};

/// Finds the AssetScopeAttribute tagged to a scope's address (scope_address - as it's referred to in
/// many places in the documentation, which is a bech32 address prefixed with "scope").
pub fn query_asset_binary_by_scope_address(
    deps: &Deps<ProvenanceQuery>,
    scope_address: impl Into<String>,
    asset_type: impl Into<String>,
) -> Result<Binary, ContractError> {
    let attribute_result = query_asset_attribute_by_scope_address(deps, scope_address, asset_type);
    if let Ok(attr) = attribute_result {
        Ok(to_binary(&attr)?)
    } else {
        Err(attribute_result.expect_err("result should be error"))
    }
}

/// Finds the AssetScopeAttribute tagged to a scope's address (scope_address) and deserializes the
/// resulting value from the resulting Binary from the cosmwasm resources.
pub fn query_asset_attribute_by_scope_address(
    deps: &Deps<ProvenanceQuery>,
    scope_address: impl Into<String>,
    asset_type: impl Into<String>,
) -> Result<AssetScopeAttribute, ContractError> {
    let state = config_read(deps.storage).load()?;
    let scope_address = scope_address.into();
    let attributes = ProvenanceQuerier::new(&deps.querier)
        .get_json_attributes::<Addr, String, AssetScopeAttribute>(
            Addr::unchecked(&scope_address),
            generate_asset_attribute_name(asset_type, state.base_contract_name),
        )?;
    // Only one scope attribute should ever be tagged on a scope.  If there are > 1, then a bug has
    // occurred, and if there are zero, then the scope being queried has never been registered with
    // the contract (or an even more terrible bug has occurred).
    if attributes.len() != 1 {
        return ContractError::InvalidScopeAttribute {
            scope_address,
            attribute_amount: attributes.len(),
        }
        .to_result();
    }
    Ok(attributes.first().unwrap().to_owned())
}

#[cfg(test)]
mod tests {
    use crate::contract::query;
    use crate::core::msg::QueryMsg;
    use crate::core::state::{AssetScopeAttribute, ValidationResult};
    use crate::query::query_asset_by_scope_address::query_asset_attribute_by_scope_address;
    use crate::testutil::onboard_asset_helpers::{test_onboard_asset, TestOnboardAsset};
    use crate::testutil::test_utilities::{
        setup_test_suite, InstArgs, DEFAULT_ASSET_TYPE, DEFAULT_SCOPE_ADDRESS,
        DEFAULT_VALIDATOR_ADDRESS,
    };
    use cosmwasm_std::testing::mock_env;
    use cosmwasm_std::{from_binary, CosmosMsg, SubMsg};
    use provwasm_mocks::mock_dependencies;
    use provwasm_std::{AttributeMsgParams, ProvenanceMsg, ProvenanceMsgParams};
    use serde_json_wasm::to_string;

    #[test]
    fn test_query_asset_by_scope_address_after_register() {
        let mut deps = mock_dependencies(&[]);
        let asset_meta_repository = setup_test_suite(&mut deps, InstArgs::default());
        test_onboard_asset(
            &mut deps,
            &asset_meta_repository,
            TestOnboardAsset::default(),
        )
        .unwrap();
        let asset_binary = query(
            deps.as_ref(),
            mock_env(),
            QueryMsg::QueryAssetByScopeAddress {
                scope_address: DEFAULT_SCOPE_ADDRESS.to_string(),
                asset_type: DEFAULT_ASSET_TYPE.to_string(),
            },
        )
        .unwrap();
        let scope_attribute = from_binary::<AssetScopeAttribute>(&asset_binary).unwrap();
        assert_eq!(
            DEFAULT_VALIDATOR_ADDRESS,
            scope_attribute.validator_address.as_str(),
            "expected the default validator address to be returned",
        );
        assert_eq!(ValidationResult::PENDING, scope_attribute.validation_result, "when initially created, the meta should show that the validator has not yet approved the asset");
    }

    #[test]
    fn test_query_asset_attribute_by_scope_address() {
        let mut deps = mock_dependencies(&[]);
        let asset_meta_repository = setup_test_suite(&mut deps, InstArgs::default());
        let result = test_onboard_asset(
            &mut deps,
            &asset_meta_repository,
            TestOnboardAsset::default(),
        )
        .unwrap();
        let scope_attr = query_asset_attribute_by_scope_address(
            &deps.as_ref(),
            DEFAULT_SCOPE_ADDRESS,
            DEFAULT_ASSET_TYPE,
        )
        .expect("the default asset should deserialize correctly");

        assert_eq!(
            1,
            result.messages.len(),
            "Only one (bind attribute) message shold be generated by onboard_asset"
        );
        if let Some(SubMsg {
            msg:
                CosmosMsg::Custom(ProvenanceMsg {
                    params:
                        ProvenanceMsgParams::Attribute(AttributeMsgParams::AddAttribute {
                            value, ..
                        }),
                    ..
                }),
            ..
        }) = result.messages.first()
        {
            assert_eq!(value.to_string(), to_string(&scope_attr).unwrap());
        } else {
            panic!("Unexpected onboard_asset resultant message type")
        }
    }
}
