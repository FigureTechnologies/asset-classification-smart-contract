{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "InitMsg",
  "description": "The struct used to instantiate the contract.  Utilized in the core [contract file](crate::contract::instantiate).",
  "type": "object",
  "required": [
    "asset_definitions",
    "base_contract_name",
    "bind_base_name"
  ],
  "properties": {
    "asset_definitions": {
      "description": "All the initial [AssetDefinitions](super::types::access_definition::AccessDefinition) for the contract.  This can be left empty and new definitions can be added later using the [Add Asset Definition](crate::execute::add_asset_definition) functionality.",
      "type": "array",
      "items": {
        "$ref": "#/definitions/AssetDefinitionInput"
      }
    },
    "base_contract_name": {
      "description": "The root name from which all asset names branch.  All sub-names specified in the [AssetDefinitions](super::types::access_definition::AccessDefinition) will use this value as their parent name.",
      "type": "string"
    },
    "bind_base_name": {
      "description": "If `true`, the contract will automatically try to bind its [base_contract_name](self::InitMsg::base_contract_name) during the instantiation process to itself.  No action will be taken if the value is `false`, but the base name will still be recorded in the contract's [state](super::state::StateV2) and be used for child names for [AssetDefinitions](super::types::access_definition::AccessDefinition).",
      "type": "boolean"
    },
    "is_test": {
      "description": "A boolean value allowing for less restrictions to be placed on certain functionalities across the contract's execution processes.  Notably, this disables a check during the onboarding process to determine if onboarded scopes include underlying record values.  This should never be set to true in a mainnet environment.",
      "type": [
        "boolean",
        "null"
      ]
    }
  },
  "definitions": {
    "AssetDefinitionInput": {
      "description": "Allows the user to optionally specify the enabled flag on an asset definition, versus forcing it to be added manually on every request, when it will likely always be specified as `true`.",
      "type": "object",
      "required": [
        "asset_type",
        "scope_spec_identifier",
        "verifiers"
      ],
      "properties": {
        "asset_type": {
          "description": "The name of the asset associated with the definition.  This value must be unique across all instances persisted in contract storage, or requests to add will be rejected.",
          "type": "string"
        },
        "bind_name": {
          "description": "Whether or not to bind a Provenance Blockchain Name Module name to this contract when this struct is used to add a new asset type to the contract.  If this value is omitted OR set to true in a request that adds an asset definition, the name derived by combining the [base_contract_name](crate::core::state::StateV2::base_contract_name) and the `asset_type` will be bound to the contract.  For example, if the base name is \"pb\" and the asset type is \"myasset,\" the resulting bound name would be \"myasset.pb\".",
          "type": [
            "boolean",
            "null"
          ]
        },
        "enabled": {
          "description": "Indicates whether or not the asset definition is enabled for use in the contract.  If disabled, requests to onboard assets of this type will be rejected.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "scope_spec_identifier": {
          "description": "A link to a scope specification that defines this asset type.  A serialized version of a [ScopeSpecIdentifier](super::scope_spec_identifier::ScopeSpecIdentifier) that allows multiple different values to be derived as a scope specification address.  Must be unique across all instances persisted in contract storage, or requests to add will be rejected.",
          "allOf": [
            {
              "$ref": "#/definitions/SerializedEnum"
            }
          ]
        },
        "verifiers": {
          "description": "Individual verifier definitions.  There can be many verifiers for a single asset type.  Each value must have a unique `address` property or requests to add will be rejected.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/VerifierDetail"
          }
        }
      }
    },
    "Decimal": {
      "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
      "type": "string"
    },
    "EntityDetail": {
      "description": "Various fields describing an entity, which could be an organization, account, etc.",
      "type": "object",
      "properties": {
        "description": {
          "description": "A short description of the entity's purpose.",
          "type": [
            "string",
            "null"
          ]
        },
        "home_url": {
          "description": "A web link that can send observers to the organization that the entity belongs to.",
          "type": [
            "string",
            "null"
          ]
        },
        "name": {
          "description": "A short name describing the entity.",
          "type": [
            "string",
            "null"
          ]
        },
        "source_url": {
          "description": "A web link that can send observers to the source code of the entity for increased transparency.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "FeeDestination": {
      "description": "Defines an external account designated as a recipient of funds during the verification process.",
      "type": "object",
      "required": [
        "address",
        "fee_percent"
      ],
      "properties": {
        "address": {
          "description": "The Provenance Blockchain bech32 address belonging to the account.",
          "type": "string"
        },
        "fee_percent": {
          "description": "The amount to be distributed to this account from the designated total [fee_percent](super::verifier_detail::VerifierDetail::fee_percent) of the containing [VerifierDetail](super::verifier_detail::VerifierDetail).  This number should always be between 0 and 1, and indicate a percentage.  Ex: 0.5 indicates 50%. For instance, if the fee total is 100nhash and the verifier detail's fee percent is .5 (50%) and the destination's fee percent is 1 (100%), then that fee destination account would receive 50nhash during the transaction, which is 100% of the 50% designated to fee accounts.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        }
      }
    },
    "SerializedEnum": {
      "description": "There is a bug in cosmwasm 1.0.0's interaction with serde-json-wasm that causes floating point operations to be added into the compiled wasm, so the previous solution of using things like AssetIdentifier directly and specifying them with a tag and content param in their serde annotation is impossible as of 1.0.0.  This solution will allow existing requests to remain identical, but not generate floating point errors.  It makes the schema less useful, but it's a hack to fix a bug, so...\n\nIt's also worth noting that this solution can only create enum switches that have Strings as their values.  Anything different will not work for this solution and will require further adaptation and hackery.",
      "type": "object",
      "required": [
        "type",
        "value"
      ],
      "properties": {
        "type": {
          "description": "Specifies the type of enum to deserialize into. Maps into one of the values specified in the impl for this struct.",
          "type": "string"
        },
        "value": {
          "description": "Specifies the string value to be used for the type.",
          "type": "string"
        }
      }
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    },
    "VerifierDetail": {
      "description": "Defines the fees and addresses for a single verifier account for an [AssetDefinition](super::asset_definition::AssetDefinition).",
      "type": "object",
      "required": [
        "address",
        "fee_destinations",
        "fee_percent",
        "onboarding_cost",
        "onboarding_denom"
      ],
      "properties": {
        "address": {
          "description": "The Provenance Blockchain bech32 address of the verifier account.",
          "type": "string"
        },
        "entity_detail": {
          "description": "An optional set of fields that define the verifier, including its name and home URL location.",
          "anyOf": [
            {
              "$ref": "#/definitions/EntityDetail"
            },
            {
              "type": "null"
            }
          ]
        },
        "fee_destinations": {
          "description": "Each account that should receive the amount designated in the [fee_percent](self::VerifierDetail::fee_percent). All of these destinations' individual [fee_percent](super::fee_destination::FeeDestination::fee_percent) properties should sum to 1.  Less amounts will cause this verifier detail to be considered invalid and rejected in requests that include it.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FeeDestination"
          }
        },
        "fee_percent": {
          "description": "The percent amount taken from the total [onboarding_cost](self::VerifierDetail::onboarding_cost) to send to the underlying [FeeDestinations](super::fee_destination::FeeDestination). This should be a number from 0 to 1, representing a percentage (ex: 0.35 = 35%).",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "onboarding_cost": {
          "description": "The total amount charged to use the onboarding process this this verifier.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "onboarding_denom": {
          "description": "The coin denomination used for this onboarding process.",
          "type": "string"
        }
      }
    }
  }
}
