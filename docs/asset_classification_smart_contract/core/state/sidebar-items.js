initSidebarItems({"fn":[["asset_definitions_v2","The main entrypoint access for AssetDefinitionV2 state. Establishes an index map for all definitions, allowing the standard save(), load() and iterator functionality. Private access to ensure only helper functions below are used."],["config_read_v2","Fetches a read-only cosmwasm storage singleton instance for loading the contract’s state."],["config_v2","Fetches a mutable reference to the storage from a DepsMutC."],["delete_asset_definition_v2_by_qualifier","Attempts to delete an existing asset definition by asset type.  Returns an error if the definition does not exist or if the deletion fails.  Returns the asset type of the deleted definition on a successful deletion."],["delete_latest_verifier_detail","Deletes an existing VerifierDetailV2 from the contract’s internal latest verifier detail storage.  This leverages the latest_verifier_detail_store function.  This function is important, as contract storage should not retain any bloat.  All verifier details should be deleted after a verification has been completed successfully, as they are a historical record that is not relevant."],["insert_asset_definition_v2","Inserts a new asset definition into storage. If a value already exists, an error will be returned. Note: Asset definitions must contain a unique asset_type value, as well as a unique scope_spec_address. Either unique constraint being violated will return an error."],["insert_latest_verifier_detail","Inserts a verifier detail into the contract’s storage, leveraging the latest_verifier_detail_store function."],["latest_verifier_detail_store","Fetches a mutable reference to the latest verifier detail storage from a DepsMutC. This storage exists for the purpose of maintaining an accurate record of the VerifierDetailV2 each scope has when it is onboarded.  As those values can technically change between the time at which an asset is onboarded versus when it is verified, it is important that the values are stored until verification is complete in order to generate the correct fees to match the onboarding cost that is held in contract escrow during onboarding."],["latest_verifier_detail_store_ro","Fetches a read-only cosmwasm storage bucket instance for loading verifier details for scope attributes.  This storage exists for the purpose of maintaining an accurate record of the VerifierDetailV2 each scope has when it is onboarded.  As those values can technically change between the time at which an asset is onboarded versus when it is verified, it is important that the values are stored until verification is complete in order to generate the correct fees to match the onboarding cost that is held in contract escrow during onboarding."],["load_asset_definition_v2_by_scope_spec","Finds an existing asset definition by scope spec address, or returns an error if no definition is found."],["load_asset_definition_v2_by_type","Finds an existing asset definition by asset type, or returns an error if no definition is found."],["may_load_asset_definition_v2_by_scope_spec","Finds an existing asset definition in state by checking against the provided scope spec address, returning an Option that reflects whether or not the definition exists."],["may_load_asset_definition_v2_by_type","Finds an existing asset definition in state by checking against the provided asset type, returning an Option that reflects whether or not the definition exists."],["replace_asset_definition_v2","Replaces an existing asset definition in state with the provided value.  If no value exists for the given definition, an error will be returned.  Note: IndexedMap (the type asset_definitions_v2 function returns) provides a really nice update() function that allows two branches (one for success and one for failure to find) that seems ideal for this functionality, but it requires a non-reference version of the data to be used. This requires that the provided definition must be cloned, which makes it vastly inefficient compared to this implementation."]],"static":[["ASSET_META_KEY",""],["LATEST_VERIFIER_DETAIL_KEY",""],["STATE_V2_KEY",""]],"struct":[["AssetDefinitionIndexesV2","Boilerplate implementation of indexes for an IndexMap around state. This establishes a unique index on the scope spec address to ensure that saves cannot include duplicate scope specs. If it becomes a requirement in the future that we have duplicate scope specs, we will need to swap to a MultiIndex, and a lot of the lookups in the contract will fall apart."],["StateV2","Stores the main configurations for the contract internally."]]});